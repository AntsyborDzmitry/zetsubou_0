{"version":3,"sources":["services/debounce-service.js"],"names":[],"mappings":";;;qBAsBwB,eAAe;;;;;;AApBvC,qBAAI,OAAO,CAAC,iBAAiB,EAAE,eAAe,CAAC,CAAC;;AAEhD,mBAAe,CAAC,OAAO,GAAG,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;;;;;;;;;;;;;;;;;;;AAkB9B,aAAS,eAAe,CAAC,EAAE,EAAE,QAAQ,EAAE;AAClD,YAAM,SAAS,GAAG;AACd,kCAAsB,EAAtB,sBAAsB;SACzB,CAAC;;AAEF,iBAAS,sBAAsB,CAAC,WAAW,EAAE,MAAM,EAAE,KAAK,EAAE,WAAW,EAAE;;;AACrE,gBAAI,OAAO,GAAG,IAAI,CAAC;AACnB,gBAAI,YAAY,GAAG,IAAI,CAAC;;AAExB,gBAAM,MAAM,GAAG,SAAT,MAAM,GAAyB;kDAAlB,aAAa;AAAb,iCAAa;;;AAC5B,oBAAM,EAAE,QAAO,CAAC;;AAEhB,6BAAa,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;;AAEjC,4BAAY,GAAG,WAAW,CAAC,KAAK,QAAO,aAAa,CAAC,IAAI,YAAY,CAAC;;AAEtE,oBAAI,CAAC,OAAO,EAAE;;AACV,4BAAM,SAAS,GAAG,SAAZ,SAAS,CAAI,KAAK;mCAAK;uCAAM,KAAK;6BAAA;yBAAA,CAAC;;AAEzC,+BAAO,GAAG,QAAQ,CACd;mCAAM,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,EAAE,YAAY,CAAC,CAAC;yBAAA,EAC9C,KAAK,EACL,WAAW,CAAC,WACA,CAAC,YAAM;AACX,mCAAO,GAAG,IAAI,CAAC;yBAClB,CAAC,CAAC;;iBACd;;AAED,uBAAO,OAAO,CAAC;aAClB,CAAC;;AAEF,mBAAO,MAAM,CAAC;SACjB;;AAED,eAAO,SAAS,CAAC;KACpB","file":"services/debounce-service.js","sourcesContent":["import ewf from 'ewf';\r\n\r\newf.service('debounceService', DebounceService);\r\n\r\nDebounceService.$inject = ['$q', '$timeout'];\r\n\r\n/**\r\n * This function creates another function that can be used for the purpose of throttling high frequency requests.\r\n * It provides the ability to aggregate incoming request data via the means of `aggregateFn`. The function receives\r\n * request data and aggregates it into `result` which is further passed to `thenFn`. Function `thenFn` receives\r\n * aggregated request data and issues processing in accordance to business logic. The result of such processing is\r\n * wrapped into closure and returned via debounceFunction promise.\r\n *\r\n * @param {Function} aggregateFn(prevAggregationResult, anyArgs..) returns aggregationResult\r\n *                   receives previous iteration aggregationResult (undefined first time) and returns\r\n *                   new aggregationResult\r\n * @param {Function} thenFn(lastAggregationResult): returns thenFnResult wrapped into closure (function)\r\n * @param {Number} delay\r\n * @param {Boolean} invokeApply\r\n * @returns {Function} function(anyArgs): Promise<clojurify<thenFnResult>> which accept lastAggregationResult and\r\n * returns promise, which resolves to value returned by `thenFn`\r\n */\r\nexport default function DebounceService($q, $timeout) {\r\n    const publicApi = {\r\n        createDebounceFunction\r\n    };\r\n\r\n    function createDebounceFunction(aggregateFn, thenFn, delay, invokeApply) {\r\n        let timeout = null;\r\n        let debounceArgs = null;\r\n\r\n        const result = (...aggregateArgs) => {\r\n            const vm = this;\r\n\r\n            aggregateArgs.push(debounceArgs);\r\n\r\n            debounceArgs = aggregateFn.apply(this, aggregateArgs) || debounceArgs;\r\n\r\n            if (!timeout) {\r\n                const clojurify = (value) => () => value;\r\n\r\n                timeout = $timeout(\r\n                    () => clojurify(thenFn.call(vm, debounceArgs)),\r\n                    delay,\r\n                    invokeApply)\r\n                        .finally(() => {\r\n                            timeout = null;\r\n                        });\r\n            }\r\n\r\n            return timeout;\r\n        };\r\n\r\n        return result;\r\n    }\r\n\r\n    return publicApi;\r\n}\r\n"],"sourceRoot":"/source/"}