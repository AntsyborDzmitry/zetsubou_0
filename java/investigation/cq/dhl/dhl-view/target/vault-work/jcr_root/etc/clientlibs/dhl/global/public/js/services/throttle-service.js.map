{"version":3,"sources":["services/throttle-service.js"],"names":[],"mappings":";;;qBAUwB,eAAe;;;;;;AARvC,qBAAI,OAAO,CAAC,iBAAiB,EAAE,eAAe,CAAC,CAAC;;AAEhD,mBAAe,CAAC,OAAO,GAAG,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;;;;;;;AAM9B,aAAS,eAAe,CAAC,EAAE,EAAE,QAAQ,EAAE;AAClD,YAAM,SAAS,GAAG;AACd,kCAAsB,EAAtB,sBAAsB;SACzB,CAAC;;;;;;;AAOF,YAAM,0BAA0B,GAAG,EAAE,CAAC;;;;;;;;;;;;;;;;;;AAkBtC,iBAAS,sBAAsB,CAAC,WAAW,EAAE,MAAM,EAAE,WAAW,EAAE;;;AAC9D,gBAAI,OAAO,GAAG,IAAI,CAAC;AACnB,gBAAI,YAAY,GAAG,IAAI,CAAC;;;;;AAKxB,gBAAI,QAAQ,GAAG,EAAE,CAAC,KAAK,EAAE,CAAC;;AAE1B,gBAAI,KAAK,GAAG,SAAR,KAAK,GAAc;AACnB,wBAAQ,GAAG,EAAE,CAAC,KAAK,EAAE,CAAC;;AAEtB,uBAAO,GAAG,IAAI,CAAC;AACf,4BAAY,GAAG,IAAI,CAAC;aACvB,CAAC;;AAEF,gBAAI,MAAM,GAAG,SAAT,MAAM,GAAyB;kDAAlB,aAAa;AAAb,iCAAa;;;AAC1B,oBAAI,EAAE,QAAO,CAAC;;AAEd,6BAAa,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;;AAEpC,4BAAY,GAAG,WAAW,CAAC,KAAK,QAAO,aAAa,CAAC,IAAI,YAAY,CAAC;;AAEtE,oBAAI,OAAO,EAAE;AACT,4BAAQ,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;iBAC5B;;AAED,uBAAO,GAAG,QAAQ,CAAC,YAAM;AACrB,wBAAM,SAAS,GAAG,SAAZ,SAAS,CAAI,KAAK;+BAAK;mCAAM,KAAK;yBAAA;qBAAA,CAAC;;;;;AAKzC,4BAAQ,CAAC,OAAO,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,EAAE,YAAY,CAAC,CAAC,CAAC,CAAC;;AAE3D,yBAAK,EAAE,CAAC;iBACX,EAAE,0BAA0B,EAAE,WAAW,CAAC,CAAC;;AAE5C,uBAAO,QAAQ,CAAC,OAAO,CAAC;aAC3B,CAAC;;AAEF,mBAAO,MAAM,CAAC;SACjB;;AAED,eAAO,SAAS,CAAC;KACpB","file":"services/throttle-service.js","sourcesContent":["import ewf from 'ewf';\r\n\r\newf.service('throttleService', ThrottleService);\r\n\r\nThrottleService.$inject = ['$q', '$timeout'];\r\n\r\n/**\r\n * Attrs service. Contains helper logic related to attribute manipulation\r\n *\r\n */\r\nexport default function ThrottleService($q, $timeout) {\r\n    const publicApi = {\r\n        createThrottleFunction\r\n    };\r\n\r\n    /*\r\n     * On system minimal timer resolution reference please review:\r\n     * http://stackoverflow.com/questions/3744032/why-are-net-timers-limited-to-15-ms-resolution\r\n     * Two system heartbeats are used for throttling to make it possible to collect all requests\r\n     */\r\n    const DEFAULT_THROTTLING_TIMEOUT = 32;\r\n\r\n    /**\r\n     * This function creates another function that can be used for the purpose of throttling high frequency requests.\r\n     * It provides the ability to aggregate incoming request data via the means of `aggregateFn`. The function receives\r\n     * request data and aggregates it into `result` which is further passed to `thenFn`. Function `thenFn` receives\r\n     * aggregated request data and issues processing in accordance to business logic. The result of such processing is\r\n     * wrapped into closure and returned via throttleFunction promise.\r\n     *\r\n     * @param {Function} aggregateFn(prevAggregationResult, anyArgs..) returns aggregationResult\r\n     *                   receives previous iteration aggregationResult (undefined first time) and returns\r\n     *                   new aggregationResult\r\n     * @param {Function} thenFn(lastAggregationResult): returns thenFnResult wrapped into closure (function)\r\n     * @param {Number} delay\r\n     * @param {Boolean} invokeApply\r\n     * @returns {Function} function(anyArgs): Promise<clojurify<thenFnResult>> which accept lastAggregationResult and\r\n     * returns promise, which resolves to value returned by `thenFn`\r\n     */\r\n    function createThrottleFunction(aggregateFn, thenFn, invokeApply) {\r\n        let timeout = null;\r\n        let throttleArgs = null;\r\n\r\n        // `defer` is used internally due to the fact that the function returns function\r\n        // instead of promise it is also required because we want to preserve the promise\r\n        // returned by `result` function even during throttling promise interchange\r\n        let deferred = $q.defer();\r\n\r\n        let reset = function() {\r\n            deferred = $q.defer();\r\n\r\n            timeout = null;\r\n            throttleArgs = null;\r\n        };\r\n\r\n        let result = (...aggregateArgs) => {\r\n            let vm = this;\r\n\r\n            aggregateArgs.unshift(throttleArgs);\r\n\r\n            throttleArgs = aggregateFn.apply(this, aggregateArgs) || throttleArgs;\r\n\r\n            if (timeout) {\r\n                $timeout.cancel(timeout);\r\n            }\r\n\r\n            timeout = $timeout(() => {\r\n                const closurify = (value) => () => value;\r\n\r\n                // we can't use code like this:\r\n                //   deferred.resolve(thenFn.call(vm, throttleArgs));\r\n                // because if thenFn.call return promise then we'll get unexpected behavior\r\n                deferred.resolve(closurify(thenFn.call(vm, throttleArgs)));\r\n\r\n                reset();\r\n            }, DEFAULT_THROTTLING_TIMEOUT, invokeApply);\r\n\r\n            return deferred.promise;\r\n        };\r\n\r\n        return result;\r\n    }\r\n\r\n    return publicApi;\r\n}\r\n"],"sourceRoot":"/source/"}