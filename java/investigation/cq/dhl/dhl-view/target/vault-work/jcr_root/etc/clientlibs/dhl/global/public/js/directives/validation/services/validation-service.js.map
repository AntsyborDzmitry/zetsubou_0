{"version":3,"sources":["directives/validation/services/validation-service.js"],"names":[],"mappings":"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","file":"directives/validation/services/validation-service.js","sourcesContent":["import ewf from 'ewf';\r\n\r\newf.service('validationService', ValidationService);\r\n\r\nValidationService.inject = ['$http', 'logService'];\r\n\r\n/**\r\n * internal breaker is used to make sure if any validation fails - next validation will not be performed\r\n */\r\nexport default function ValidationService($http, logService) {\r\n    this.applyRulesValidators = applyRulesValidators;\r\n\r\n    const breaker = {};\r\n    const validators = {\r\n        required: function requiredValidator(model) {\r\n            return (value) => {\r\n                //if any validations were failed earlier, then we need to skip this one\r\n                if (value === breaker) {\r\n                    //... and set validity to true to make sure only previously failed validation will be shown\r\n                    model.$setValidity('required', true);\r\n\r\n                    //... and also return breaker as we do not have possibility to interrupt queue.\r\n                    return breaker;\r\n                }\r\n\r\n                const valid = !model.$isEmpty(value);\r\n\r\n                model.$setValidity('required', valid);\r\n\r\n                //returned breaker will notify next validators that this one were failed\r\n                return valid ? value : breaker;\r\n            };\r\n        },\r\n        formatted: function formattedValidator(model) {\r\n            return (value) => {\r\n                if (value === breaker) {\r\n                    model.$setValidity('formatted', true);\r\n\r\n                    return breaker;\r\n                }\r\n\r\n                const valid = isFormatValid(model, value);\r\n\r\n                model.$setValidity('formatted', valid);\r\n\r\n                return valid ? value : breaker;\r\n            };\r\n        },\r\n        exist: function existValidator(model) {\r\n            return (value) => {\r\n                if (value === breaker) {\r\n                    model.$setValidity('exist', true);\r\n\r\n                    return breaker;\r\n                }\r\n\r\n                $http.post('/api/user/validate/email', {\r\n                    email: value\r\n                })\r\n                .success((response) => {\r\n                    const valid = !response.exist;\r\n\r\n                    model.$setValidity('exist', valid);\r\n\r\n                    return value;\r\n                })\r\n                .error((error) => {\r\n                    logService.error(`There are some issues contacting server. ${error}`);\r\n\r\n                    model.$setValidity('exist', false);\r\n\r\n                    return breaker;\r\n                });\r\n\r\n                return value;\r\n            };\r\n        },\r\n        matches: function matchesValidator(model) {\r\n            return (value) => {\r\n                if (value === breaker) {\r\n                    model.$setValidity('matches', true);\r\n\r\n                    return breaker;\r\n                }\r\n\r\n                const valid = value === '' ? true : value === model.matches.$viewValue;\r\n\r\n                model.$setValidity('matches', valid);\r\n\r\n                return valid ? value : breaker;\r\n            };\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Apply proper validation rules adding parsers\r\n     * @param {Object} model Current directive model\r\n     * @param {Array} rules Rules that model must be validated against\r\n     */\r\n    function applyRulesValidators(model, rules) {\r\n        model.$parsers = rules.map((rule) => validators[rule](model)).concat(model.$parsers);\r\n    }\r\n\r\n    /**\r\n     * Checks if value fits validation rules; first check light \"max-length\" rule, then check heavy \"pattern\" rule\r\n     * @param {Object} model Current directive model\r\n     * @param {String} value Entered value\r\n     * @returns {Boolean} if value fits email regexp and max length\r\n     */\r\n    function isFormatValid(model, value) {\r\n        return value.length <= model.maxLength && model.pattern.test(value);\r\n    }\r\n}\r\n"],"sourceRoot":"/source/"}